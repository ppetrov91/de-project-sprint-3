## 1. Пояснения к таблице load_staging_history.

  1. Поскольку DAG может позволяет повторно загружать не только инкрементальные, но и основные данные, то
     даты событий могут отличаться и отличаются в основых данных.

     Например, минимальная дата события 2023-11-27, а максимальная 2023-12-29.

     Эти данные хранятся в полях min_date и max_date, они нужны для перезаписи данных в слоях staging и mart.

     В файлах с инкрементальными данными min_date = max_date.

  2. Поле file_dt и status нужны для проверки успешности загрузки staging слоя. С помощью file_dt

     можно узнать все файлы, которые были загружены за определённуб дату, а с помощью status можно оценить успешность загрузки 

     данных. Если статус хотя бы одного файла не success, то слой mart не обновляется.

## 2. Пояснения к работе DAG.

  0. Перед запусками DAG нужно выполнить скрипты в migrations, при этом create_utils_schema.sql должен выполняться последним, поскольку он добавляет дополнительные поля в таблицы схемы staging и mart.

  1. DAG можно использовать не только для загрузки инурементальных данных, но и основных. Для передачи основных

     данных нужно в качестве dt указать пустую строку или None.

  2. Проверяется статус сформированного отчёта, если статус NOT FOUND, то загрузка в staging слой    
     останавливается, в таблицу staging.load_staging_history в поле status записывается not_found.

  3. Файлы данных сохраняются в директорию staging рядом с dags, они нужны для хранения истории согласно спринту.

  4. Таблицы staging слоя друг от друга не зависят, поэтому данные в них можно загружать независимо друг
     от друга.

  5. В таблицы d_city, d_customer и d_item добавлены поля created_at и updated_at, они нужны для обновления данных. Данные обновляются при срабатывании конструкции ON CONFLICT DO UPDATE, при этом значение хотя бы одного неключевого поля staging данных должно отличаться от данных в схеме mart. Также дата формирования строки в системе-источнике должно быть больше значения поля create_at, если поле updated_at IS NULL или больше значения поля updated_at. Таким образом, обеспечивается актуальность данных в таблицах-измерениях.

  6. Таблицы слоя mart обновляются только в случае успешной загрузки всех файлов слоя staging.

  7. Таблицы update_d_city, update_d_item и update_d_calendar не зависят друг от друга, поэтому задания по их обработке можно распараллелить.

  8. Перед обновлением данных в таблице-фактов удаляются записи, дата формирования которых находится между значений min_date и max_date таблицы staging.load_staging_history. Это позволяет удалять данные только тех периодов, которые подлежат обновлению, и избежать появления дубликатов.

  9. Таблицы фактов f_sales и f_activity не зависят друг от друга, поэтому задания по их обработке можно распараллелить. Но при этом их нужно обрабатывать только после успешной обработки таблиц-фактов.

  10. Таблица фактов f_customer_retention зависит от f_sales, поэтому задание по её обработке запускается только после завершения обработки f_sales и f_activity.
